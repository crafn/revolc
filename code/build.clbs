# Build instructions

# `clbs -j4` - build with development configuration in 4 threads
# `clbs debug`, `clbs dev` or `clbs release` - build everything with respective configuration
# `clbs revolc` or `clbs mod` - build certain parts of the codebase
# `clbs <cfg> clean` - removes all objects, libraries and executables
# Flag `-v` can be used to see actual compilation and linking commands

# When working with engine, desired command usually is
# `clbs -j8 dev revolc`

# When working with game, desired command usually is
# `clbs -j8 dev mod`

def buildInfo(env, tags):
	def runCodegen(p, input_file, output_file, gen_also_math):
		log("running codegen")
		preproc_path= "./obj/preproc_tmp" + str(p._compileHash)
		cmd= p.compiler + " -DCODEGEN -E " + input_file + " -o " + preproc_path
		for i in p.includeDirs:
			cmd += " -I" + i
		os.system(cmd)

		# http://stackoverflow.com/questions/4664850/find-all-occurrences-of-a-substring-in-python
		def find_all(a_str, sub):
			start = 0
			while True:
				start = a_str.find(sub, start)
				if start == -1: return
				yield start
				start += len(sub)

		# Really crappy struct member parsing code follows -- should be enough until jai arrives

		def isWhitespace(ch):
			return ch == ' ' or ch == '\t' or ch == '\n' or ch == '\r'

		def isIdentChar(ch):
			return ch.isalpha() or ch == '_'

		# "  dfdsk,  "
		#    ^ ->  ^
		def tokEnd(str, index):
			i= index
			while i < len(str) and not isWhitespace(str[i]):
				i += 1
			return i

		# "    <tab> <newline> something"
		#  ^         ->        ^
		def nextTok(str, index):
			i= index
			while i < len(str) and isWhitespace(str[i]):
				i += 1
			return i

		def findNext(str, index, ch):
			i= index
			while i < len(str) and str[i] != ch:
				i += 1
			return i

		# "*name[123][23446/325 + 0x35];" -> "name"
		def trimMemberName(messy):
			begin= 0
			while begin < len(messy) and not isIdentChar(messy[begin]):
				begin += 1
			end= begin
			while end < len(messy) and isIdentChar(messy[end]):
				end += 1
			return messy[begin : end]

		# [ ["type", "name", is_flexible_array], ... ]
		def parseMembers(str, b, e):
			types_and_names= []
			i= nextTok(str, b)
			skip_next= 1
			type_candidate= ""
			while i < e:
				tok= str[i:tokEnd(str, i)]
				skip= skip_next > 0
				if tok in ["const", "struct", "unsigned", "signed"]:
					skip= True
					skip_next += 1 # Skip type

				if not skip:
					is_flexible_array= "[]" in tok
					types_and_names.append([ type_candidate, trimMemberName(tok), is_flexible_array ])
					while i < e and (str[i] != ';' and str[i] != ','):
						i += 1
					if str[i] == ';':
						skip_next += 1 # Skip type
					i= nextTok(str, tokEnd(str, i + 1))
				else:
					if skip_next > 0:
						skip_next -= 1
					type_candidate= str[i : tokEnd(str, i)] # @todo Handle pointer names
					i= nextTok(str, tokEnd(str, i))
			return types_and_names

		structs_and_members= {}
		with open(preproc_path, "rb") as file:
			contents= file.read()

			typedef_begins= list(find_all(contents, "typedef struct"));
			for begin in typedef_begins:
				name_b= begin + len("typedef struct ")

				# Our types should always start with a capital letter
				# This filters out "typedef struct { } ASd" and typedef struct __internal"
				if contents[name_b] < 'A' or contents[name_b] > 'Z':
					continue 

				name_e= tokEnd(contents, name_b)
				struct_name= contents[name_b : name_e];

				# Check that there's an opening brace
				# @todo allow "foo{"
				brace_i= nextTok(contents, name_e)
				if contents[brace_i] != '{':
					continue

				closing_brace_i= findNext(contents, brace_i, '}')
				if closing_brace_i > findNext(contents, brace_i + 1, '{'):
					continue # @todo Allow nested structs


				structs_and_members[struct_name]= parseMembers(contents, brace_i + 1, closing_brace_i)

		# Write struct infos to file
		with open(output_file, "wb") as f:
			f.write("// This file is automatically generated (codegen)\n\n")
			f.write("#include \"platform/stdlib.h\" // MEMBER_SIZE, MEMBER_OFFSET\n\n")
			for struct, members in structs_and_members.iteritems():
				f.write("DLL_EXPORT const U32 " +struct+ "_size= sizeof(" +struct+ ");\n")

				f.write("DLL_EXPORT const char *" +struct+ "_member_names[]= {\n")
				for m in members:
					f.write("\t\"" +m[1]+ "\",\n")
				f.write("\t0\n};\n")

				f.write("DLL_EXPORT const char *" +struct+ "_member_type_names[]= {\n")
				for m in members:
					f.write("\t\"" +m[0]+ "\",\n")
				f.write("\t0\n};\n")

				f.write("DLL_EXPORT const U32 " +struct+ "_member_sizes[]= {\n")
				for m in members:
					if m[2] == True:
						f.write("\t0,\n") # Flexible array member
					else:
						f.write("\tMEMBER_SIZE(" +struct+ ", " +m[1]+ "),\n")
				f.write("};\n")

				f.write("DLL_EXPORT const U32 " +struct+ "_member_offsets[]= {\n")
				for m in members:
					f.write("\tMEMBER_OFFSET(" +struct+ ", " +m[1]+ "),\n")
				f.write("};\n")

	def filterStrs(strs, list):
		for s in strs:
			list= filter(lambda x: s not in x, list)
		return list
	def findCplFiles(dir, exts):
		return filterStrs([ "unity.c" ], findFiles(dir, exts))

	if len(tags) == 0:
		tags= [ "dev" ]

	# Clang is a lot faster than gcc, but windows support is still poor
	c_compiler= { "linux": "clang", "windows": "gcc" }[env.os]
	linker= "ld"
	lib_dir= "./lib"
	common_dep_dir= "./deps/common"
	dep_include_paths= []
	dep_defines= []
	# Common libs with unity build
	dep_include_paths += [
		common_dep_dir,
		common_dep_dir + "/chipmunk/include",
		common_dep_dir + "/vorbis/include",
		common_dep_dir + "/ogg/include",
	]
	only_revolc= "revolc" in tags
	only_mod= "mod" in tags
	build_deps= not only_revolc and not only_mod
	build_revolc= only_revolc or not only_mod

	### Codegen ##

	codegen_dir= "./tools/codegen"
	codegen= Project();
	codegen.name= "codegen"
	codegen.type= "exe"
	codegen.targetDir= "."
	codegen.includeDirs= [ codegen_dir ]
	codegen.headers= [ codegen_dir + "/main.c" ]
	codegen.src= [ codegen_dir + "/unity.c" ]
	codegen.flags= [ "std=gnu99", "w", "O3" ]
	codegen.defines= [ "GCC_BASE=NULL" ]
	codegen.compiler= c_compiler
	codegen.linker= linker


	cfg= "" # debug or dev
	target_defines= []
	target_flags= [ "std=gnu99", "pipe", "fvisibility=hidden" ]

	if env.os != "windows":
		target_flags += [ "ffast-math" ] # Caused at problems at least in Chipmunk (High EPA warning)

	if "debug" in tags:
		cfg= "debug"
		target_defines += [ "DEBUG" ]
		target_flags += [ "g", "O0", "mtune=native", "march=native" ]
	elif "dev" in tags:
		cfg= "dev"
		target_flags += [ "g", "O2", "mtune=native", "march=native" ]
	else:
		fail("Invalid tags: " + str(tags))

	deps_libname= "deps_" + cfg
	if build_deps:
		dep_lib_paths= []
		dep_libs= []

		# PortAudio
		if env.os == "windows":
			pa_dir= "./deps/win/portaudio-19"
			pa= Project()
			if build_deps:
				pa.name= "portaudio_" + cfg
				pa.type= "obj"
				pa.targetDir= lib_dir
				pa.includeDirs= [
					pa_dir + "/include",
					pa_dir + "/src/common",
					pa_dir + "/src/os/win" ]
				pa.headers= findFiles(pa_dir, "*.h")
				pa.src= findFiles(pa_dir + "/src/common", "*.c") +\
						findFiles(pa_dir + "/src/os/win", "*.c") +\
						findFiles(pa_dir + "/src/hostapi/dsound", "*.c") # Not sure
				pa.flags= target_flags + ["w"]
				pa.defines= target_defines + [ "PA_USE_DS" ]
				pa.compiler= c_compiler
				pa.linker= linker
				dep_libs.append(pa)
			dep_include_paths.append(pa_dir + "/include")

		deps_proj= Project()
		deps_proj.name= deps_libname
		deps_proj.type= "lib"
		deps_proj.targetDir= lib_dir
		deps_proj.includeDirs= dep_include_paths + [ common_dep_dir + "./chipmunk/src", common_dep_dir + "/vorbis/lib" ]
		deps_proj.headers= findCplFiles(common_dep_dir, ["*.h", "*.c"])
		deps_proj.src= [ common_dep_dir + "/unity.c" ]
		deps_proj.flags= target_flags + [ "O3" ]
		deps_proj.defines= target_defines
		deps_proj.compiler= c_compiler
		deps_proj.linker= linker

		for d in dep_libs:
			deps_proj.deps.append(d)
			deps_proj.links.append(d)

	### Clover engine ###

	revolc_src_dir= "./source"
	revolc_flags= target_flags + [
		"Wall", "Werror",
		"Wno-unused-function"
	]
	revolc_defines= target_defines + dep_defines
	revolc_includedirs= [ revolc_src_dir ] + dep_include_paths
	revolc_libdirs= [ lib_dir ]
	if env.os == "windows":
		# win-builds mingw is broken.
		win_builds_bin_paths= \
			[s for s in os.environ["PATH"].split(";") if "win-builds" in s]
		if len(win_builds_bin_paths) > 0:
			revolc_libdirs += [ win_builds_bin_paths[0] + "/../lib" ]
		# mingw ignores __attribute__((packed)) by default, silently. This fixes it.
		revolc_flags += [ "mno-ms-bitfields" ]
		# mingw generates totally bogus "may be uninitialized" warnings in dev build
		revolc_flags += [ "Wno-maybe-uninitialized" ]

	if build_revolc:
		system_links= [ "m" ]
		if env.os == "linux":
			system_links += [ "pthread", "portaudio", "GL", "GLU", "Xrandr", "Xxf86vm", "Xi", "X11", "dl" ]
		elif env.os == "windows":
			system_links += [ "glu32", "opengl32", "gdi32", "wsock32", "ws2_32", "winmm", "ole32", "kernel32" ]

		build_dest_dir= "../builds/" + env.os + env.arch[1:]

		revolc= Project()
		revolc.name= "revolc_" + cfg
		revolc.type= "exe"
		revolc.targetDir= build_dest_dir
		revolc.includeDirs= revolc_includedirs
		revolc.libDirs= revolc_libdirs
		revolc.headers= filterStrs(["/mod/"], findCplFiles(revolc_src_dir, ["*.h", "*.def", "*.c"]))
		revolc.src= [ revolc_src_dir + "/unity.c" ]
		revolc.flags= revolc_flags
		revolc.defines= revolc_defines
		revolc.compiler= c_compiler
		revolc.linker= linker
		revolc.prebuild= lambda p: runCodegen(p, revolc.src[0], revolc_src_dir + "/global/gen_rtti.c", True)

		if build_deps:
			revolc.deps += [ deps_proj ]
		revolc.deps += [ codegen ]

		if env.os == "linux":
			revolc.links += [ "--export-dynamic" ]
		revolc.links += [ deps_libname ]
		revolc.links += system_links
		if env.os == "windows": # Create importlib to engine for dll's
			revolc.links += [ "--export-all-symbols", "--out-implib," + lib_dir + "/librevolc_stubs.a" ]

	### Game DLL ###

	resource_dir= "../resources/gamedata"
	mod_src_dir= revolc_src_dir + "/mod"
	mod= Project()
	mod.name= "mod"
	mod.type= "dll"
	mod.targetDir= resource_dir
	mod.includeDirs= revolc_includedirs
	mod.libDirs= revolc_libdirs
	mod.headers= findCplFiles(mod_src_dir, ["*.h", "*.c"])
	mod.src= [ mod_src_dir + "/unity.c" ]
	mod.flags= revolc_flags
	mod.defines= revolc_defines
	mod.compiler= c_compiler
	mod.linker= linker
	mod.deps = [ codegen ]
	mod.prebuild= lambda p: runCodegen(p, mod.src[0], mod_src_dir + "/gen_rtti.c", False)

	if build_revolc:
		mod.deps += [ revolc ]
	if env.os == "linux":
		pass # Linked at runtime
	elif env.os == "windows":
		# Undefined references not allowed in windows DLL
		mod.links += [ "revolc_stubs" ]
	return mod
