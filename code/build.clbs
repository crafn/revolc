# Build instructions

# `clbs clover -j4` - build with development configuration in 4 threads
# `clbs clover debug`, `clbs dev` or `clbs release` - build everything with respective configuration
# `clbs clover revolc` or `clbs mod` - build certain parts of the codebase
# `clbs <cfg> clean` - removes all objects, libraries and executables
# Flag `-v` can be used to see actual compilation and linking commands

# When working with engine, desired command usually is
# `clbs -j8 dev revolc`

# When working with clover, desired command usually is
# `clbs -j8 dev clover`

# When working with rts, desired command usually is
# `clbs -j8 dev rts`

def buildInfo(env, tags):
	def runCodegen(p, input_file, output_file, gen_also_math):
		log("running codegen")
		preproc_path= "./obj/preproc_tmp" + str(p._compileHash)
		cmd= p.compiler + " -DCODEGEN -E " + input_file + " -o " + preproc_path
		for i in p.includeDirs:
			cmd += " -I" + i
		os.system(cmd)

		# http://stackoverflow.com/questions/4664850/find-all-occurrences-of-a-substring-in-python
		def find_all(a_str, sub):
			start = 0
			while True:
				start = a_str.find(sub, start)
				if start == -1: return
				yield start
				start += len(sub)

		# Really crappy struct member parsing code follows -- should be enough until jai arrives

		def isWhitespace(ch):
			return ch == ' ' or ch == '\t' or ch == '\n' or ch == '\r'

		def isIdentChar(ch):
			return ch.isalnum() or ch == '_'

		# "  dfdsk,  "
		#    ^ ->  ^
		def tokEnd(str, index):
			i= index
			while i < len(str) and not isWhitespace(str[i]):
				i += 1
			return i

		# "    <tab> <newline> something"
		#  ^         ->        ^
		def nextTok(str, index):
			i= index
			while i < len(str) and isWhitespace(str[i]):
				i += 1
			if str[i] == '#':
				while i < len(str) and str[i] != '\n':
					i += 1 # Skip line
				return nextTok(str, i)
			return i

		def findNext(str, index, ch):
			i= index
			while i < len(str) and str[i] != ch:
				i += 1
			return i

		# "*name[123][23446/325 + 0x35];" -> "name"
		def trimMemberName(messy):
			begin= 0
			while begin < len(messy) and not isIdentChar(messy[begin]):
				begin += 1
			end= begin
			while end < len(messy) and isIdentChar(messy[end]):
				end += 1
			return messy[begin : end]

		typename_ix = 0
		name_ix = 1
		ptr_depth_ix = 2
		is_flexible_array_ix = 3
		# [ ["type", "name", ptr_depth, is_flexible_array], ... ]
		def parseMembers(str, b, e):
			types_and_names= []
			i= nextTok(str, b)
			skip_next= 1
			type_candidate= ""
			while i < e:
				tok= str[i:tokEnd(str, i)]
				skip= skip_next > 0
				if tok in ["const", "struct", "unsigned", "signed"]:
					skip= True
					skip_next += 1 # Skip type

				if not skip:
					is_flexible_array= "[]" in tok
					ptr_depth = 0
					k = 0
					while tok[k] == '*':
						ptr_depth += 1
						k += 1
					types_and_names.append([ type_candidate, trimMemberName(tok), ptr_depth, is_flexible_array ])
					while i < e and (str[i] != ';' and str[i] != ','):
						i += 1
					if str[i] == ';':
						skip_next += 1 # Skip type
					i= nextTok(str, tokEnd(str, i + 1))
				else:
					if skip_next > 0:
						skip_next -= 1
					type_candidate= str[i : tokEnd(str, i)] # @todo Handle pointer names
					i= nextTok(str, tokEnd(str, i))
			return types_and_names

		structs_and_members= {}
		with open(preproc_path, "rb") as file:
			contents= file.read()

			typedef_begins= list(find_all(contents, "typedef struct"));
			for begin in typedef_begins:
				name_b= begin + len("typedef struct ")

				# Our types should always start with a capital letter
				# This filters out "typedef struct { } ASd" and typedef struct __internal"
				if contents[name_b] < 'A' or contents[name_b] > 'Z':
					continue 

				name_e= tokEnd(contents, name_b)
				struct_name= contents[name_b : name_e];

				# Check that there's an opening brace
				# @todo allow "foo{"
				brace_i= nextTok(contents, name_e)
				if contents[brace_i] != '{':
					continue

				closing_brace_i= findNext(contents, brace_i, '}')
				if closing_brace_i > findNext(contents, brace_i + 1, '{'):
					continue # @todo Allow nested structs


				structs_and_members[struct_name]= parseMembers(contents, brace_i + 1, closing_brace_i)

		# Write struct infos to file
		with open(output_file, "wb") as f:
			f.write("// This file is automatically generated (codegen)\n\n")
			f.write("#include \"core/basic.h\" // MEMBER_SIZE, MEMBER_OFFSET\n")
			f.write("#include \"global/rtti.h\" // StructRtti, MemberRtti\n\n")
			for struct, members in structs_and_members.iteritems():
				f.write("DLL_EXPORT MemberRtti " +struct+ "_members[] = {\n")
				for m in members:
					member_size = "MEMBER_SIZE(" +struct+ ", " +m[name_ix]+ ")";
					if m[is_flexible_array_ix] == True:
						member_size = "0"
					f.write("\t{ \"" +m[name_ix]+ "\", \"" +m[typename_ix]+ "\", " +str(m[ptr_depth_ix])+ ", " + "MEMBER_OFFSET(" +struct+ ", " +m[name_ix]+ "), " +member_size+ " },\n")
				f.write("};\n")

				f.write("DLL_EXPORT StructRtti " +struct+ "_rtti = { \"" +struct+ "\", sizeof(" +struct+ "), " +struct+ "_members, " +str(len(members))+ " };\n")


	def filterStrs(strs, list):
		for s in strs:
			list= filter(lambda x: s not in x, list)
		return list
	def findCplFiles(dir, exts):
		return filterStrs([ "unity.c" ], findFiles(dir, exts))

	if len(tags) == 0:
		tags= [ "dev" ]

	# Clang is a lot faster than gcc, but windows support is still poor
	c_compiler= { "linux": "clang", "windows": "gcc" }[env.os]
	linker= "ld"
	lib_dir= "./lib"
	common_dep_dir= "./deps/common"
	dep_include_paths= []
	dep_defines= []
	# Common libs with unity build
	dep_include_paths += [
		common_dep_dir,
		common_dep_dir + "/chipmunk/include",
		common_dep_dir + "/vorbis/include",
		common_dep_dir + "/ogg/include",
	]
	only_revolc= "revolc" in tags
	only_clover= "clover" in tags
	only_rts= "rts" in tags
	only_something= only_revolc or only_clover or only_rts
	build_deps= only_revolc or not only_something
	build_revolc= only_revolc or not only_something
	build_clover= only_clover or not only_something
	build_rts= not build_clover and (only_rts or not only_something)

	cfg= "" # debug or dev
	target_defines= []
	target_flags= [ "std=gnu99", "pipe", "fvisibility=hidden" ]

	if env.os != "windows":
		# Caused problems at least in Chipmunk 7.0.0 (High EPA warning)
		# That function has been now updated to 7.0.1, so could try enabling this again
		target_flags += [ "ffast-math" ]

	if "debug" in tags:
		cfg= "debug"
		target_defines += [ "BUILD=1" ]
		target_flags += [ "g", "O0" ]
	elif "dev" in tags:
		cfg= "dev"
		target_flags += [ "g", "O2", "mtune=native", "march=native" ]
		target_defines += [ "BUILD=2" ]
	else:
		fail("Invalid tags: " + str(tags))

	deps_libname= "deps_" + cfg
	dep_libs= []
	# PortAudio for windows
	if env.os == "windows":
		pa_dir= "./deps/win/portaudio-19"
		pa= Project()
		if build_deps:
			pa.name= "portaudio_" + cfg
			pa.type= "obj"
			pa.targetDir= lib_dir
			pa.includeDirs= [
				pa_dir + "/include",
				pa_dir + "/src/common",
				pa_dir + "/src/os/win" ]
			pa.headers= findFiles(pa_dir, "*.h")
			pa.src= findFiles(pa_dir + "/src/common", "*.c") +\
					findFiles(pa_dir + "/src/os/win", "*.c") +\
					findFiles(pa_dir + "/src/hostapi/dsound", "*.c") # Not sure
			pa.flags= target_flags + ["w"]
			pa.defines= target_defines + [ "PA_USE_DS" ]
			pa.compiler= c_compiler
			pa.linker= linker
			dep_libs.append(pa)
		dep_include_paths.append(pa_dir + "/include")

	if build_deps:
		dep_lib_paths= []

		deps_proj= Project()
		deps_proj.name= deps_libname
		deps_proj.type= "lib"
		deps_proj.targetDir= lib_dir
		deps_proj.includeDirs= dep_include_paths + [ common_dep_dir + "./chipmunk/src", common_dep_dir + "/vorbis/lib" ]
		deps_proj.headers= findCplFiles(common_dep_dir, ["*.h", "*.c"])
		deps_proj.src= [ common_dep_dir + "/unity.c" ]
		deps_proj.flags= target_flags + [ "O2" ] # O3 causes chipmunk queries to fail occasionally on windows
		deps_proj.defines= target_defines
		deps_proj.compiler= c_compiler
		deps_proj.linker= linker

		for d in dep_libs:
			deps_proj.deps.append(d)
			deps_proj.links.append(d)

	### Revolc engine ###

	revolc_src_dir= "./source"
	revolc_flags= target_flags + [
		"Wextra", "Wall", "Werror",
		"Wno-unused-function",
		"Wno-unused-parameter", # Apparently C doesn't allow nameless parameters
		"Wno-missing-field-initializers", # They're meant to be initialized to zero
	]
	revolc_defines= target_defines + dep_defines
	revolc_includedirs= [ revolc_src_dir ] + dep_include_paths
	revolc_libdirs= [ lib_dir ]
	if env.os == "windows":
		# win-builds mingw is broken.
		win_builds_bin_paths= \
			[s for s in os.environ["PATH"].split(";") if "win-builds" in s]
		if len(win_builds_bin_paths) > 0:
			revolc_libdirs += [ win_builds_bin_paths[0] + "/../lib" ]
		# mingw ignores __attribute__((packed)) by default, silently. This fixes it.
		revolc_flags += [ "mno-ms-bitfields" ]
		# mingw generates totally bogus "may be uninitialized" warnings in dev build
		revolc_flags += [ "Wno-maybe-uninitialized" ]

	if build_revolc:
		system_links= [ "m" ]
		if env.os == "linux":
			system_links += [ "pthread", "portaudio", "GL", "GLU", "Xrandr", "Xxf86vm", "Xi", "X11", "dl" ]
		elif env.os == "windows":
			system_links += [ "glu32", "opengl32", "gdi32", "wsock32", "ws2_32", "winmm", "ole32", "kernel32" ]

		build_dest_dir= "../builds/" + env.os + env.arch[1:]

		revolc= Project()
		revolc.name= "revolc_" + cfg
		revolc.type= "exe"
		revolc.targetDir= build_dest_dir
		revolc.includeDirs= revolc_includedirs
		revolc.libDirs= revolc_libdirs
		revolc.headers= filterStrs(["/clover/", "/rts/"], findCplFiles(revolc_src_dir, ["*.h", "*.def", "*.c"]))
		revolc.src= [ revolc_src_dir + "/unity.c" ]
		revolc.flags= revolc_flags
		revolc.defines= revolc_defines
		revolc.compiler= c_compiler
		revolc.linker= linker
		revolc.prebuild= lambda p: runCodegen(p, revolc.src[0], revolc_src_dir + "/global/gen_rtti.c", True)

		if build_deps:
			revolc.deps += [ deps_proj ]
		#revolc.deps += [ codegen ]

		if env.os == "linux":
			revolc.links += [ "--export-dynamic" ]
		revolc.links += [ deps_libname ]
		revolc.links += system_links
		if env.os == "windows": # Create importlib to engine for dll's
			revolc.links += [ "--export-all-symbols", "--out-implib," + lib_dir + "/librevolc_stubs.a" ]

	### Game DLL ###
	game= None
	if build_clover and build_rts:
		fail("Can't build both clover and rts")

	if build_clover:
		resource_dir= "../resources/clover"
		clover_src_dir= revolc_src_dir + "/clover"
		clover= Project()
		clover.name= "clover"
		clover.type= "dll"
		clover.targetDir= resource_dir
		clover.includeDirs= revolc_includedirs
		clover.libDirs= revolc_libdirs
		clover.headers= findCplFiles(clover_src_dir, ["*.h", "*.c"])
		clover.src= [ clover_src_dir + "/unity.c" ]
		clover.flags= revolc_flags
		clover.defines= revolc_defines
		clover.compiler= c_compiler
		clover.linker= linker
		#clover.deps = [ codegen ]
		clover.prebuild= lambda p: runCodegen(p, clover.src[0], clover_src_dir + "/gen_rtti.c", False)
		game= clover
	elif build_rts:
		resource_dir= "../resources/rts"
		rts_src_dir= revolc_src_dir + "/rts"
		rts= Project()
		rts.name= "rts"
		rts.type= "dll"
		rts.targetDir= resource_dir
		rts.includeDirs= revolc_includedirs
		rts.libDirs= revolc_libdirs
		rts.headers= findCplFiles(rts_src_dir, ["*.h", "*.c"])
		rts.src= [ rts_src_dir + "/unity.c" ]
		rts.flags= revolc_flags
		rts.defines= revolc_defines
		rts.compiler= c_compiler
		rts.linker= linker
		#rts.deps = [ codegen ]
		rts.prebuild= lambda p: runCodegen(p, rts.src[0], rts_src_dir + "/gen_rtti.c", False)
		game= rts

	if game == None:
		return revolc

	if build_revolc:
		game.deps += [ revolc ]

	if env.os == "linux":
		pass # Linked at runtime
	elif env.os == "windows":
		# Undefined references not allowed in windows DLL
		game.links += [ "revolc_stubs" ]
	return game
