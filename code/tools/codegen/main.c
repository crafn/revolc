#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <sparse/lib.h>
#include <sparse/allocate.h>
#include <sparse/token.h>
#include <sparse/parse.h>
#include <sparse/scope.h>
#include <sparse/symbol.h>
#include <sparse/expression.h>
#include <sparse/linearize.h>

#define MAX_STRUCT_COUNT (1024*4)
#define MAX_STRUCT_MEMBER_COUNT 128

typedef struct StructInfo {
	struct symbol *sym;
	struct symbol *member_syms[MAX_STRUCT_MEMBER_COUNT];
	int member_count;
} StructInfo;

StructInfo struct_infos[MAX_STRUCT_COUNT];
int struct_info_count;

static void examine_namespace(struct symbol *sym)
{
	if (sym->ident && sym->ident->reserved)
		return;

	switch(sym->namespace) {
	case NS_MACRO:
		break;
	case NS_STRUCT: {
		if (sym->type == SYM_UNION)
			break;
		if (!sym->ident)
			break;
		if (!sym->ident->name)
			break;
		if (sym->ident->name[0] == '_')
			break;
		if (sym->ident->name[0] > 'Z')
			break;
		if (	sym->ident->name[0] == 'L' &&
				sym->ident->name[1] == 'o' &&
				sym->ident->name[2] == 'd' &&
				sym->ident->name[3] == 'e') // Lode png lib
			break;
		if (	sym->ident->name[0] == 'P' &&
				sym->ident->name[1] == 'a') // PortAudio
			break;

		{
			int illegal= 0;
			int count= 0;
			struct symbol *m= NULL;
			FOR_EACH_PTR(sym->symbol_list, m) {
				++count;
				if (!m->ident || !m->ident->name || m->ident->name[0] == '_') {
					illegal= 1;
					break;
				}
			} END_FOR_EACH_PTR(m);
			if (illegal || count == 0)
				break;
		}

		assert(struct_info_count < MAX_STRUCT_COUNT);
		StructInfo *s= &struct_infos[struct_info_count++];
		s->sym= sym;

		struct symbol *m;
		FOR_EACH_PTR(sym->symbol_list, m) {
			assert(s->member_count < MAX_STRUCT_MEMBER_COUNT);
			s->member_syms[s->member_count++]= m;
		} END_FOR_EACH_PTR(m);
		break;
	} case NS_TYPEDEF:
	case NS_SYMBOL:
	case NS_NONE:
	case NS_LABEL:
	case NS_ITERATOR:
	case NS_UNDEF:
	case NS_PREPROCESSOR:
	case NS_KEYWORD:
		break;
	default:
		die("Unrecognised namespace type %d",sym->namespace);
	}
}

static inline void examine_symbol_list(const char *file, struct symbol_list *list)
{
	struct symbol *sym;

	if (!list)
		return;
	FOR_EACH_PTR(list, sym) {
			examine_namespace(sym);
	} END_FOR_EACH_PTR(sym);
}

static void write_rtti()
{
	/// @todo Don't hard-code
	char *sparse_argv[]= {
		"codegen",
		"-I/usr/include/",
		"-I/usr/include/x86_64-linux-gnu/",
		"-I/usr/lib/gcc/x86_64-linux-gnu/4.8/include/",
		"-I./source/",
		"-I./deps/common/",
		"-I./deps/common/chipmunk/include/",
		"-DCODEGEN",
		"./source/unity.c",
		NULL
	};
	const int sparse_argc= sizeof(sparse_argv)/sizeof(*sparse_argv);

	struct string_list *filelist = NULL;
	char *file;
	sparse_initialize(sparse_argc, sparse_argv, &filelist);
	FOR_EACH_PTR_NOTAG(filelist, file) {
		sparse_keep_tokens(file);
		examine_symbol_list(file, file_scope->symbols);
	} END_FOR_EACH_PTR_NOTAG(file);

	//
	// Code generation
	//

	FILE *h= fopen("./source/global/generated_rtti.h", "wb");
	assert(h);
	FILE *c= fopen("./source/global/generated_rtti.c", "wb");
	assert(h);
	assert(c);

	fprintf(h, "#ifndef REVOLC_GLOBAL_RTTI_H\n");
	fprintf(h, "#define REVOLC_GLOBAL_RTTI_H\n\n");
	fprintf(h, "// This file is automatically generated (codegen)\n\n");

	fprintf(c, "#include \"generated_rtti.h\"\n\n");

	for (int i= 0; i < struct_info_count; ++i) {
		StructInfo *s= &struct_infos[i];

		// Struct size
		fprintf(h, "extern const U32 %s_size;\n", s->sym->ident->name);
		fprintf(c, "const U32 %s_size= sizeof(%s);\n", s->sym->ident->name, s->sym->ident->name);

		// Member names
		fprintf(h, "extern const char *%s_member_names[];\n", s->sym->ident->name);
		fprintf(c, "const char *%s_member_names[]= {\n", s->sym->ident->name);
		for (int k= 0; k < s->member_count; ++k) {
			fprintf(c, "	\"%s\",\n", s->member_syms[k]->ident->name);
		}
		fprintf(c, "	NULL\n};\n");

		// Member sizes
		fprintf(h, "extern const U32 %s_member_sizes[];\n", s->sym->ident->name);
		fprintf(c, "const U32 %s_member_sizes[]= {", s->sym->ident->name);
		for (int k= 0; k < s->member_count; ++k) {
			struct symbol *m= get_base_type(s->member_syms[k]);
			int byte_size= m->bit_size/8;
			if (byte_size == 0) // Happens with bools for some reason
				byte_size= 1;
			fprintf(c, "%i, ", byte_size);
		}
		fprintf(c, "};\n");

		// Member offsets
		fprintf(h, "extern const U32 %s_member_offsets[];\n", s->sym->ident->name);
		fprintf(c, "const U32 %s_member_offsets[]= {\n", s->sym->ident->name);
		for (int k= 0; k < s->member_count; ++k) {
			struct symbol *m= s->member_syms[k];
			fprintf(c, "	offsetof(%s, %s),\n",
					s->sym->ident->name,
					m->ident->name);
		}
		fprintf(c, "};\n");
	}
	fprintf(h, "\n#endif // REVOLC_GLOBAL_RTTI_H\n");

	fclose(h);
	fclose(c);
}

static void write_math()
{
	FILE *f= fopen("./source/core/vector.h", "wb");
	assert(f);

	typedef struct VecType {
		const char *name;
		const char *lc_name;
		const char *comp_type_name;
		int comp_count;
		int round_to;
	} VecType;

	VecType vecs[]= {
		{"V2d", "v2d", "F64", 2, 2},
		{"V2f", "v2f", "F32", 2, 2},
		{"V2i", "v2i", "S32", 2, -1},
		{"V3d", "v3d", "F64", 3, -1},
		{"V3f", "v3f", "F32", 3, -1},
	};
	const int vec_count= sizeof(vecs)/sizeof(*vecs);

	const char *comp_names[4]= {"x", "y", "z", "w"};

	fprintf(f, "#ifndef REVOLC_CORE_VECTOR_H\n");
	fprintf(f, "#define REVOLC_CORE_VECTOR_H\n");
	fprintf(f, "\n// This is a generated file (codegen)\n\n");
	fprintf(f, "#include <math.h>\n\n");

	for (int i= 0; i < vec_count; ++i) {
		VecType v= vecs[i];
		fprintf(f, "typedef struct %s {\n", v.name);
		for (int k= 0; k < v.comp_count; ++k) {
			fprintf(f, "	%s %s;\n", v.comp_type_name, comp_names[k]);
		}
		fprintf(f, "} %s;\n\n", v.name);
	}

	for (int i= 0; i < vec_count; ++i) {
		VecType v= vecs[i];

		fprintf(f, "static\n");
		fprintf(f, "bool equals_%s(%s a, %s b)\n", v.lc_name, v.name, v.name);
		fprintf(f, "{ return ");
		for (int k= 0; k < v.comp_count; ++k)
			fprintf(f, "a.%s == b.%s && ", comp_names[k], comp_names[k]);
		fprintf(f, "1; }\n");

		fprintf(f, "static\n");
		fprintf(f, "%s add_%s(%s a, %s b)\n", v.name, v.lc_name, v.name, v.name);
		fprintf(f, "{ return (%s) {", v.name);
		for (int k= 0; k < v.comp_count; ++k) {
			fprintf(f, "a.%s + b.%s, ", comp_names[k], comp_names[k]);
		}
		fprintf(f, "}; }\n");

		fprintf(f, "static\n");
		fprintf(f, "%s sub_%s(%s a, %s b)\n", v.name, v.lc_name, v.name, v.name);
		fprintf(f, "{ return (%s) {", v.name);
		for (int k= 0; k < v.comp_count; ++k) {
			fprintf(f, "a.%s - b.%s, ", comp_names[k], comp_names[k]);
		}
		fprintf(f, "}; }\n");

		fprintf(f, "static\n");
		fprintf(f, "%s mul_%s(%s a, %s b)\n", v.name, v.lc_name, v.name, v.name);
		fprintf(f, "{ return (%s) {", v.name);
		for (int k= 0; k < v.comp_count; ++k) {
			fprintf(f, "a.%s * b.%s, ", comp_names[k], comp_names[k]);
		}
		fprintf(f, "}; }\n");

		fprintf(f, "static\n");
		fprintf(f, "%s scaled_%s(%s s, %s v)\n", v.name, v.lc_name, v.comp_type_name, v.name);
		fprintf(f, "{ return (%s) {", v.name);
		for (int k= 0; k < v.comp_count; ++k) {
			fprintf(f, "s*v.%s, ", comp_names[k]);
		}
		fprintf(f, "}; }\n");

		fprintf(f, "static\n");
		fprintf(f, "%s length_sqr_%s(%s v)\n", v.comp_type_name, v.lc_name, v.name);
		fprintf(f, "{ return ");
		for (int k= 0; k < v.comp_count; ++k)
			fprintf(f, "v.%s*v.%s + ", comp_names[k], comp_names[k]);
		fprintf(f, "0; }\n");

		fprintf(f, "static\n");
		fprintf(f, "F64 length_%s(%s v)\n", v.lc_name, v.name);
		fprintf(f, "{ return sqrt(length_sqr_%s(v)); }\n", v.lc_name);

		fprintf(f, "static\n");
		fprintf(f, "%s dist_sqr_%s(%s a, %s b)\n", v.comp_type_name, v.lc_name, v.name, v.name);
		fprintf(f, "{ return ");
		for (int k= 0; k < v.comp_count; ++k)
			fprintf(f, "(a.%s - b.%s)*(a.%s - b.%s) + ", comp_names[k], comp_names[k], comp_names[k], comp_names[k]);
		fprintf(f, "0; }\n");

		fprintf(f, "static\n");
		fprintf(f, "F64 dist_%s(%s a, %s b)\n", v.lc_name, v.name, v.name);
		fprintf(f, "{ return sqrt(dist_sqr_%s(a, b)); }\n", v.lc_name);

		fprintf(f, "static\n");
		fprintf(f, "%s normalized_%s(%s v)\n", v.name, v.lc_name, v.name);
		fprintf(f, "{ return scaled_%s(1.0/length_%s(v), v); }\n", v.lc_name, v.lc_name);

		if (v.comp_count == 2) {
			fprintf(f, "static\n");
			fprintf(f, "%s rot_%s(F64 f, %s v)\n", v.name, v.lc_name, v.name);
			fprintf(f, "{ return (%s) {v.x*cos(f) - v.y*sin(f), v.x*sin(f) + v.y*cos(f)}; }\n", v.name);
		}

		if (v.round_to != -1) {
			VecType r= vecs[v.round_to];
			fprintf(f, "static\n");
			fprintf(f, "%s round_%s_to_%s(%s v)\n", r.name, v.lc_name, r.lc_name, v.name);
			fprintf(f, "{ return (%s) {", r.name);
			for (int k= 0; k < v.comp_count; ++k) {
				fprintf(f, "floor(v.%s + 0.5), ", comp_names[k]); 
			}
			fprintf(f, "}; }\n");
		}
	}

	fprintf(f,
		"static\n"
		"V2d v3d_to_v2d(V3d v)\n"
		"{ return (V2d) {v.x, v.y}; }\n");
	fprintf(f, "\n#endif\n");

	fclose(f);
}

int main(int argc, char **argv)
{
	write_math();

	write_rtti();
	return 0;
}

